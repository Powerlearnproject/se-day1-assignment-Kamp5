[![Open in Visual Studio Code](https://classroom.github.com/assets/open-in-vscode-2e0aaae1b6195c2367325f4f02e2d04e9abb55f0b24a779b69b11b9e10269abc.svg)](https://classroom.github.com/online_ide?assignment_repo_id=15571255&assignment_repo_type=AssignmentRepo)

# SE_Day1
Software Engineering Day1 Assignment

#Part 1: Introduction to Software Engineering

Explain what software engineering is and discuss its importance in the technology industry. 
SOFTWARE ENGINEERING ENCOMPASSES THE COINCISE AND SYSTEMATIC ENGINEERING PRINCIPLE OF DOCUMENTATION, DESIGN AND DEVELOPMENT OF SOFTWARES, THE CREATED SOFTWARE WILL ALSO BE INCLUSIVE OF TESTING, DEPLOYMENT AND MAINTENANCE. THESE SOFTWARE WILL ALSO BE OPTIMISED TO ATTAIN HIGH QUALITY THAT IS RELIABLE, SCALEBLE AND BE MAINTAINED IN THE PROCESS OF CUSTOMER USAGE AND INTERACTION.


Identify and describe at least three key milestones in the evolution of software engineering.
1) ADVENT OF SOFTWARES THAT ARE OPEN SOURCES: AVAILABILITY OF OPEN SOURCE GIVES DEVELOPERS ACCESS TO SOFTWARES THAT ARE FREE AND AVAILABLE FOR USE IN THE COURSE OF CREATING SOFTWARES FOR USERS. OPEN SOURCE SOFTWARES HAVE INCREASE DEVELOPMENT ANS CODE SHARING AMONGST OTHER DEVELOPERS.

2) ADVENT OF OBJECT ORIENTED PROGRAMMING LANGUAGE: THE DEVELOPMENT OF "OBJECT ORIENTED PROGRAMMING LANGUAGE" OOP SINCE ITS INCEPTION HAS MADE IT EASY FOR PROGRAM SEGMENTING INTO SMALLER OBJECTS THATS RESPONSIBLE FOR DESIGNATED FUNCTIONS, MAKING IT EASY FOR SOTWARE SYSTEM MANAGEMENT AND MAINTENANCE.

3) ADVENT OF OOP HAS ALLOW CODES TO BE ABLE TO BE RE-USEACROSS DIFFERENT PARTS OF A PLATFORM


List and briefly explain the phases of the Software Development Life Cycle.
1) DOCUMENTATION: THIS PROCESS INVOLVES SPELLING OUT THE SCOPE OF A PROJECT THAT WILL BE UNDERTAKEN. THIS PHASE WILL HAVE A VIVID DESCRIPTION OF THE FLOW AND STAGES ON WHICH THE SOFTWARE TO BE PRODUCED SHOULD FOLLOW FOR CLARITY.

2) DESCRIPTIVE ANALYSIS: THIS INCLUDES THE FUNTIONALITIES THATS EXPECTED FROM THE SOFTWARE PRODUCED. OTHER FUNCTIONAL REQUIREMENTS WILL ALSO BE INCLUSIVE OF UI/UX INTERPHASE AND SECURITY DEFENCE DESIGN

3) DESIGNING OF SYSTEM: THIS STAGE PROVIDES VIVID AND CLEAR MASTERPLAN FOR THE DEVELOPERS TO EMULATE IN THE CAUSE OF THE PROJECT DEVELOPMENT. THE OVERAL SHAPE OF THE SOFTWARE, ITS FLOW AND INTERFACE IS DETERMINED BASE ON ITS DESCRITIVE ANALYSIS.

4) CODE DEVELOPMENT: AT THIS STAGE, A CODE IS WRITTEN BASE ON THE WRITTEN OUT "DESCRIPTIVE ANALYSIS AND DESIGN SYSTEM". WRITTEN CODES ARE INTEGRATE WITH APIs' TO ACHIEVE PRECISE FUNTIONALITY, WITH USER INTERFACE AND SECURITY.

5) TESTING: THIS IS WHEN THE WRITTEN CODES ARE TESTED FOR BUGS AND THEIR FUNCTIONALITIES ARE TESTED TO ENSURE ALL MODULES, APIs' AND DEVICE RESOLUTIONS ARE PROPER, BASE ON THE SCREEN YOU'RE VIEWING FROM. ALL BUGS MUST BE FIXED AT THIS STAGE.

6) DEPLOYMENT: AT THIS STAGE, VIGOROUS TESTING HAS BEEN DONE TO BE SURE OF ITS FUNCTIONALITY BEFORE ITS BEEN PUT OUT THERE FOR  END USERS TO DOWNLOAD AND CONFIGURE ON THEIR DEVICES.

7) MAINTENANCE: THIS STAGE IS MEANT TO CARRY ON FOR AS LLONG AS THE SOFTWARE STAYS OUT THERE FOR USER CONSUMPTION. CONSTANT MONITORING OF THE PRODUCT FOR BUGS ARE CARRIED OUT, AND ONCE FOUND FIXES AND UNPADES ARE REQUIRED TO KEEP THE SOFTWARE IN GOOD CONDITION FOR END USERS.


Compare and contrast the Waterfall and Agile methodologies. Provide examples of scenarios where each would be appropriate.
1) WATERFALL METHODOLOGY: THIS METHOD OF IS MORE EMPHATIC ON DOCUMENTAION OF A PROJECT, HIGHLIGHTING EVERY STEP THAT SHOULD BE TAKEN WHILE PRODUCING. AS THE NAME SUGGESTS, ITS LIKE A FLOW FROM THE TOP TO THE BOTTOM OF THE LAYED OUT SEQUENTIAL APPROACH WHICH EVERY STEP PRECEEDES THE NEXT LINE OF ACTION TO BE TAKEN. THIS METHOLOGY CAN BE IMPLOYED IN BUILDING A SOFTWARE SYSTEM FOR A VOTING SYSTEM, WHERE COMPLIANCE WITH OUTLINED REGULATIONS PRIOR TO ITS PRODUCTION.

2) AGILE METHODOLOGY: IN AN AGILE METHODOLOGY, THE PROJECT PROCESS ARE DECIMATED INTO SMALLER BITS OR STAGES. THIS PROCESS IS EMPHATIC ON TEAMS THAT ARE BUILDING DIFFERENT STAGES OF A PROJECT TO COLABORATE  AND WORK IN TIME, RELAYING FEEBACK TO PROJECTS MANAGERS AND ALL SENIOR PROJECT MANAGERS. THIS PROCESS IS USE IN THE BUILDING OF MOBILE APPS OR ONLINE SERVICE DELIVERY APPS.


Describe the roles and responsibilities of a Software Developer, a Quality Assurance Engineer, and a Project Manager in a software engineering team.
1) A SOFTWARE DEVELOPER: THE MAIN OBJECTIVE OF A SOFTWARE DEVELOPER IS  WRITING OUT FUNCTIONING CODES, DESIGNING OF WRITTEN CODES, COLLABORATION OF WRITTEN CODES ACROSS PLATFORMS AND ALSO WITH TEAM MEMBERS, TESTING, DEPLOYMENT AND CONTINEOUS MAINTENANCE TO GET RID OF BUGS, SET UP UPDATES AND PROTECT AGAINST INTRUDES AND THREAT.

2) QUALITY ASSURANCE ENGINEER: THE QUALITY ASSURANCE ENGINEER IS RESPONSIBLE FOR TESTING, AND LOOKING OUT FOR BUGS IN THE CODES WRITTEN BY A DEVELOPER. TESTING OF APP FUNCTIONALITIES, APP PERFORMANCE AND COMMUNICATING PROJECT PROGRESSION WITH SENIOR MANAGERS, PROJECT OWNERS AND OTHER STAKEHOLDERS.

3) PROJECT MANAGER: THE PROJECT MANAGER HAVE TO LOOK OUT FOR THE EXPECTATIONS OF THE PROJECT AND ENSURE ITS FRUITION BY TESTING PROJECT PACE OF PROGRESSION, PROJECT QUALITY AND MEETING PRE DESTINED TIME OF DELIVERY.  CORDINATIONS OF TEAMS COLLABORATING IN THE PROJECTS AND PROGRESS TRACKING.


Discuss the importance of Integrated Development Environments (IDEs) and Version Control Systems (VCS) in the software development process. Give examples of each.
1) Integrated Development Environments: THE IDEs' IS A POWERFUL CODE WRITING DASHBOARD THAT HELPS IN READABLE CODING LANGUAGE AND STRUCTURING OF CODING SYNTAX, ASSISTING IN CODE COMPLITION  WHICH MAKE THE DEVELOPERS CODING PROCESS FASTER AND EASY. EXAMPLE OF IDEs' ARE VS CODE, ELLIPSE ETC

2) VERSION CONTROL SYSTEM: THIS SYSTEM MAKES DIFFERENT TEAM OF DEVELOPERS TO COLLABORATE AND WRITE OUT CODES FOR LARGE PROJECTS WITHOUT INTERFERANCE OR CASES OF ONE TEAM MEMBER OVER WRITING THE WORK OF ANOTHER. IT KEEPS HISTORY OF CHANGES MADE EVERYSTEP ALONG THE WAY WHEN CODES ARE BEING WRITTEN BY DIFFERENT COLLABORATING TEAMS. EXAMPLES ARE MERCURIAL, GIT ETC.

What are some common challenges faced by software engineers? Provide strategies to overcome these challenges.
1) CATCHING UP WITH CONSTANTLY EVOLVING TECHNOLOGIES: PERIODIC STUDY AND RESEARCHING ON THE LATEST DEVELOPMENTS OUT THERE. THIS ROUTINE CAN BE DONE MONTHLY OR WEEKLY DEPENDING ON THE SPARE TIME AVAILABLE TO THE DEVELOPER, NOT FORGETTING THE FOUNDAMENTALS OF SOFTWARE ENGINEERING, PRINCIPLE AND KNOWLEDGE CAUSE THESE ARE THE PILLARS ON WHICH OLD AND NEW PROGRAMS AND WILL BE BUILT ON.

2) MANAGEMENT OF TIME: TIME MANAGEMENT IS ONE OF THE MOST DAUNTING CHALLENGE DEVELOPERS ARE FACED WITH, EXPECIALLY IN CASES WHERE MULTIPLE PROJECTS ARE BEING HANDLED. THIS CHALLENGE CAN BE MANAGED BY PRIORITIZING PROJECTS AT HAND AND KEEPING TO DEADLINES BY MEANS OF USING TIME TRACKING MEANS WHILE WORKING. MULTI TASKING MAY BE OF AN ADVERSE ADVANTAGE AS ROOM FOR ERROR IS INEVITABLE. FATIGUE AND BURNING MAY FOLLOW.

3) SECURITY CONCIOUSNESS: THERE IS ALWAYS A HUGE BURDEN ON THE SHOULDER OF DEVELOPERS WHILE DEVELOPING A PROJECT, THERE IS ALWAYS A DESIRE TO MITIGATE AGAINST HAVING BUGS WHICH MAY LEAD TO REPUTATIONAL DAMAGE, LOSS OF CONFIDENTIAL INFORMATIONS AND DATE, LIKEWISE LOSS OF FINANCES. ROUTINE SECURITY TESTS ARE TO BE CARRIED OUT WHILE WORKING, PRACTICING OF ETHICAL PROGRAMMING RULES.

Explain the different types of testing (unit, integration, system, and acceptance) and their importance in software quality assurance.

1) UNIT TESTING: IN UNIT TESTING, SINGLE CODE UNITS ARE TESTED INDEPENDENTLY FROM OTHERS FOR THEIR INDIVIDUAL PERFORMANCE AND RATING IN ORDER TO BE SURE THEIR PERFOMANCE ARE PRECISE AS PREDESTINED. METHOD, CLASSES AND FUNCTIONS ARE THAT CAN BE TESTED AND THE AIM IS TO BE SURE OF THEIR FUCTIONALITY.

2) INTEGRATION TESTING: THIS IS THE PROCESS OF DIFFERENT INTERFACE AND MODULES VERIFICATION TO ASCERTAIN THEIR THE FLOW OF DATA ACROSS MODULES AND UNITS INTERFACE. THE PROCESS ALSO INCLUDE THE USER INPUT INTERFACE AND VERIFICATION WITH THE DATA BASE TO GAIN ACCESS.

3) SYSTEM TESTING: THE PROCESS OF PUTTING A FULLY DEVELOPED SOFTWARE TO TEST IN ORDER TO LOOKOUT FOR ITS  FUNCTIONAL AND NON FUNCTIONAL REQUIREMENTS. IN THIS PROCESS, SOFTWARE IS RUN IN A SYSTEM THAT LOOKS LIKE THAT OF THE END USER TO BE SURE OF IT PERFORMANCE LIKE SCREEN RESOLUTION ACROSS DEVICE, USER INTERACTION WITH THE SOFTWARE, LOOK OUT FOR DELAY RESPONSE WHEN USER ENGAGES, SECURITY CONCERNS AND CRASHES.

4) ACCEPTANCE TESTING: THIS STAGE IS INCLUSIVE OF THE "BUSINESS ACCEPTANCE TESTING: THIS IS WHEN THE SOFTWARE IS TESTED TO BE SURE THE BUSINESS REASON FOR THE DEVELOPED SOFTWARE IS MET, AND THE FUNCTIONALITIES ARE AS DESIRED.
"USER ACCEPTANCE TEST: THE PROCESS OF MAKING SURE THE DEVELOPED SOFTWARE MEETS THE USER FRIENDLY REQUIREMENTS NEEDED FOR SEAMLESS OPERATION BEFORE DEPLOYMETS"
"REGULATORY ACCEPTANCE TEST: THE PROCES OF REVIEWING THE DEVELOPED SOFTWARE TO BE SURE REGULATORY RULES OR LAWS ARE NOT VIOLATED"


#Part 2: Introduction to AI and Prompt Engineering


Define prompt engineering and discuss its importance in interacting with AI models.
THE PROCESS OF STRUCTING THE DESIRED INPUT TO BE GIVEN TO AN AI FOR OPTIMIZED FEEDBACK TO BE RECEIVED. THIS INVOLVES THE PRECISED USE OF WORS IN PROMPTING QUESTIONS OR INSTRUCTIONS GIVEN TO THE AI FOR PROCESSING AND DELIVERING INDEPTH ANSWERS THAT BEST FIT THE INPUT GIVEN. THE IMPORTANCE OF GIVING COINCISE PROMPTS IS TO MAXIMIZE THE QUALITY OF FEEDBACK GIVEN. IT PERMITS THE SPECIFIC DEFINITION OR EXPLANATION GIVEN DEPENDING ON THE FIELD OF SPECIALTY THE USER WANTS THE FEEDBACK TO BE CENTERED ON.


Provide an example of a vague prompt and then improve it by making it clear, specific, and concise. Explain why the improved prompt is more effective.
VAGUE PROMPTS: DEFINE TUPLES
IMPROVED PROMPTS: AS AN EXPERT IN SOFTWARE ENGINEERING WITH SPECIFICATION IN PYTHON PROGRAMMING LANGUAGE, DEFINE THE TERM "TUPLES" GIVING EXAMPLES AND SCENARIOS WHERE THEY ARE AND ARE NOT APPLICABLE.
